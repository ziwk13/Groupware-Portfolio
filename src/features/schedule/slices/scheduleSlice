// ==============================|| scheduleSlice.js ||============================== //

import { createSlice } from '@reduxjs/toolkit';
import axios from 'utils/axios';
import { dispatch } from 'store';

const initialState = {
  error: null,
  events: [],
  loading: false
};

const slice = createSlice({
  name: 'schedule',
  initialState,
  reducers: {
    startLoading(state) {
      state.loading = true;
    },
    hasError(state, action) {
      state.loading = false;
      state.error = action.payload;
    },
    getEventsSuccess(state, action) {
      state.loading = false;
      state.events = action.payload || [];
    },
    addEventSuccess(state, action) {
      state.loading = false;
      state.events.push(action.payload);
    },
    // ✅ 서버가 content를 안 보내도 기존 값을 보존하도록 머지
    updateEventSuccess(state, action) {
      const updated = action.payload; // { scheduleId, ...변경필드 }
      state.loading = false;
      state.events = state.events.map((e) => {
        if (e.scheduleId !== updated.scheduleId) return e;

        return {
          ...e,
          ...updated,
          // 아래 필드는 undefined일 때 원래 값 유지
          content: updated.content !== undefined ? updated.content : e.content,
          categoryCode: updated.categoryCode !== undefined ? updated.categoryCode : e.categoryCode,
          colorCode: updated.colorCode !== undefined ? updated.colorCode : e.colorCode,
          allDay: updated.allDay !== undefined ? updated.allDay : e.allDay
        };
      });
    }
  }
});

export default slice.reducer;

// ==============================|| ACTIONS ||============================== //

// 전체 일정 조회
export const getEvents = () => async () => {
  try {
    dispatch(slice.actions.startLoading());
    const response = await axios.get('/api/schedules');
    const data = response.data?.data || response.data;
    dispatch(slice.actions.getEventsSuccess(data));
  } catch (error) {
    dispatch(slice.actions.hasError(error));
  }
};

// 일정 등록
export const addEvent = (eventData) => async () => {
  try {
    dispatch(slice.actions.startLoading());
    const response = await axios.post('/api/schedules', eventData);
    const data = response.data?.data || response.data;
    dispatch(slice.actions.addEventSuccess(data));
  } catch (error) {
    dispatch(slice.actions.hasError(error));
  }
};

// ✅ 일정 수정 (기존 값 보존해서 안전 머지)
export const updateEvent = (scheduleId, updatedData) => async (dispatch, getState) => {
  try {
    dispatch(slice.actions.startLoading());

    // 현재 스토어에서 기존 이벤트 가져오기 (content/코드 유지)
    const state = getState();
    const prev = state.schedule.events.find((e) => e.scheduleId === Number(scheduleId)) || {};

    // 서버 호출
    const response = await axios.put(`/api/schedules/${scheduleId}`, updatedData);
    const server = response.data?.data || {};

    // 최종으로 리듀서에 보낼 페이로드: 기존 + 클라이언트 변경 + 서버 응답
    const merged = {
      ...prev,
      ...updatedData,
      ...server,
      scheduleId: Number(scheduleId)
    };

    dispatch(slice.actions.updateEventSuccess(merged));
  } catch (error) {
    dispatch(slice.actions.hasError(error));
  }
};

// 일정 삭제
export const deleteEvent = (scheduleId) => async (dispatch) => {
  try {
    await axios.delete(`/api/schedules/${scheduleId}`);
    // 필요하면 여기에 삭제 리듀서 추가해서 프론트에서도 즉시 제거하도록 구현 가능
    // dispatch(slice.actions.deleteEventSuccess(Number(scheduleId)));
  } catch (error) {
    dispatch(slice.actions.hasError(error));
  }
};
